package Brute_Force1;

import java.io.BufferedReader;
import java.io.FileReader;

/**
 * This class will attempt to solve the suduko puzzle. 
 * 
 */
public class Solver
{
	private int[][] puzzle;
	private int[][] checker;
	private int width;
	private int height;
	private int size;

	/**
	 * 	The constructor for the solver class. Accepts a string parameter to build the puzzle array from by parsing through a text file,
	 * 
	 * @param puzzleName
	 * @throws Exception
	 */
	public Solver(String puzzleName) throws Exception
	{
		BufferedReader reader = new BufferedReader(new FileReader(puzzleName));

		String temp = reader.readLine();

		if(temp.charAt(0) == 'c')
		{
			temp = reader.readLine();	
		}

		width = Integer.parseInt(temp);
		temp = reader.readLine();
		height = Integer.parseInt(temp);
		temp = reader.readLine();
		size = (height * width);

		puzzle = new int[size][size];
		int currentHeight = 0;

		while(temp != null)
		{	
			String[] input = temp.split(" ");

			for(int currentWidth = 0; currentWidth < input.length; currentWidth++)
			{						
				puzzle[currentWidth][currentHeight]  = Integer.parseInt(input[currentWidth]);
			}

			temp = reader.readLine();
			currentHeight++;
		}

		checker = new int[size][size];
		for(int i = 0; i < size; i++)
		{
			for(int j = 0; j < size; j++)
			{
				checker[i][j] = puzzle[i][j];
			}
		}

		reader.close();
	}


	/**
	 * 	The public solve function that is used to call the recursive method that does the real work. 
	 * 
	 * @return
	 */
	public boolean solve()
	{
		return solver(0, 0);
	}


	/**
	 * 	This private method is the engine and main workhorse of the project. It will iterate in order through the 2D array representing the suduko puzzle. If it ever encounters
	 *  an immutable value that is already in the puzzle it will skip that cell. When evaluating a cell it will attempt to plug every possible value into that location without 
	 * 	violating the rules of the puzzle. If no possible values are found then we will backtrack to the previous cell increment that value to the next. 
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	private boolean solver(int x, int y)
	{
		if(checker[x][y] != 0)
		{
			return next(x, y);
		}

		int check = (puzzle[x][y] + 1);

		while(check <= size)
		{
			if(rowChecker(x, check) && columnChecker(y, check) && boxChecker(x, y, check))
			{
				puzzle[x][y] = check;
				return next(x, y);
			}

			check++;
		}

		return previous(x, y);
	}


	/**
	 * 	This method will move the cell we are currently evaulating to the next location in the array. If we have reached the final location in array then we can
	 * 	conclude that the puzzle has been properly solved and a true boolean will be returned.
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	private boolean next(int x, int y)
	{	
		if(x == (size - 1) && (y == (size - 1)))
		{
			System.out.println("Congratulations, your puzzle has been solved.");
			return true;
		}

		if(x < (size - 1))
		{
			return solver((x + 1), y);
		}

		return solver(0, (y + 1));
	}


	/**
	 * 	This method will move the cell we are currently evaluating back to the previous location. If we have already backtracked to the beginning of the array 
	 * 	then we can conclude that the puzzle is unsolvable and a false boolean will be returned. If a previous location is immutable then we will simply skip over it 
	 * 	and try to backtrack to the cell prior to that one. 
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	private boolean previous(int x, int y)
	{
		if((x == 0) && (y == 0))
		{
			System.out.println("Infinite Sadness! This puzzle is unsolvable.");
			return false;
		}

		if(x > 0)
		{
			if(checker[(x - 1)][y] != 0)
			{
				return previous((x - 1), y);
			}

			return solver((x - 1), y);
		}

		if(checker[(size - 1)][(y - 1)] != 0)
		{
			return previous((size - 1), (y - 1));
		}

		return solver((size - 1), (y - 1));
	}


	/**
	 * 	Accepts a value and a column space. Will return a boolean depending on whether or not the given value can be placed 
	 * 	in the specified column without violating the rules of the suduko game.
	 * 
	 * @param column
	 * @param value
	 * @return
	 */
	private boolean columnChecker(int column, int value)
	{
		for(int row = 0; row < size; row++)
		{
			if(puzzle[row][column] == value)
			{
				return false;
			}
		}

		return true;
	}


	/**
	 * 	Accepts a value and a row space. Will return a boolean depending on whether or not the given value can be placed 
	 * 	in the specified row without violating the rules of the suduko game.
	 * 
	 * @param row
	 * @param value
	 * @return
	 */
	private boolean rowChecker(int row, int value)
	{
		for(int column = 0; column < size; column++)
		{
			if(puzzle[row][column] == value)
			{
				return false;
			}
		}

		return true;
	}


	/**
	 * 	Accepts a value and a sub-box space. Will return a boolean depending on whether or not the given value can be placed 
	 * 	in the specified sub-box without violating the rules of the suduko game.
	 * 
	 * @param currentRow
	 * @param currentColumn
	 * @param value
	 * @return
	 */
	private boolean boxChecker(int currentRow, int currentColumn, int value)
	{
		int xLim = (width - 1);
		while(currentRow > xLim)
		{
			xLim += width;
		}

		int yLim = (height - 1);
		while(currentColumn > yLim)
		{
			yLim += height;
		}

		for(int r = 0; r < width; r++)
		{
			for(int c = 0; c < height; c++)
			{
				if(puzzle[xLim - r][yLim - c] == value)
				{
					return false ;
				}
			}
		}

		return true ;
	}


	/*
	 * 	Dummy method that prints the array to the console and splits it into easily identifiable sub-boxes.
	 * 
	 */
	public void displaySplitPuzzle()
	{
		for(int currentHeight = 0; currentHeight < size; currentHeight++)
		{
			for(int currentWidth = 0; currentWidth < size; currentWidth++)
			{
				System.out.print(puzzle[currentWidth][currentHeight]);
				System.out.print("   ");
				if((currentWidth + 1) % width == 0)
				{
					System.out.print("   ");
				}
			}
			System.out.println();
			if((currentHeight + 1) % height == 0)
			{
				System.out.println();
			}
		}
	}


	/**
	 * Dummy method that prints the puzzle array to the console.
	 * 
	 */
	public void displayPuzzle()
	{
		for(int currentHeight = 0; currentHeight < size; currentHeight++)
		{
			for(int currentWidth = 0; currentWidth < size; currentWidth++)
			{
				System.out.print(puzzle[currentWidth][currentHeight]);
				System.out.print("   ");
			}
			System.out.println();
		}
	}		
}
